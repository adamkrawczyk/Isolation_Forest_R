---
title: "ZUM Projekt"
autor: Zhan Banzekulivakha. Adam Krawczyk
last update date: "28 05 2021"
output: html_notebook
---
## Opis projektu
**Temat projektu:** Nienadzorowana detekcja anomalii za lasu izolacyjnego. Funkcje do tworzenia modelu i predykcji. Porównanie z nadzorowaną detekcją anomalii za pomocą dostępnych w R algorytmów klasyfikacji.

## Struktura katalogów w projekcie przedstawia się nastepująco:
* **data** - katalog przechowyjący dane wejściowy
* **info** - katalog przechowujący sprawozdanie porjektu
* **src**  - katalog przechowujący kod żrodłowy
* **isolation_forest.Rmd** - główny plik (notatnik) zawierajcy kod źródłowy
* **isolation_forest.html** - plik wynikowy generowany na podstawie isolation_forest.Rmd

## Wymagane biblioteki na potrzeby projektu

* **ggplot2** - biblioteka udostępnająca narzedzia do tworzenia grafiki, opartym na The Grammar of Graphics.
* **solitude** - biblioteka udostępnająca narzędzia do implementacji Isolation forest, operta na pracy:
* **R.matlab** - biblioteka dla wczytywania plików o formacie .mat
* **class** - biblioteka udostępniająca algorytm knn
* **caret** - biblioteka confisuionMatrix
*"Isolation-Based Anomaly Detection"* (FEI TONY LIU, KAI MING TING, ZHI-HUA ZHOU)

```{r message=FALSE, warning=FALSE}
library(ggplot2)
library(solitude)
library(R.matlab)
library(class)
library(caret)
# need for confusedMatrix
#install.packages('e1071', dependencies=TRUE)

source("src/IsolationForest.R") 
```

### Przygotowanie danych

* load_mat_data - wczytuje dane z pliku o formacie .mat do tabeli
* load_data - wczytuje dane z pliku do tabeli (data frame-u) w formacie innych niż *.mat
* print_mat_data_info - funkcja wypisująca informacja o plikach formatu *.mat. 

```{r}
load_mat_data <- function(path) {
  return(readMat(path))
}

load_data <- function(path) {
  return(read.table(path, sep = ",", header = TRUE))
}

prepare_mat_data <- function(mat_data) {
  df <- data.frame(mat_data$X)
  return(cbind(label = mat_data$y, df))
}

print_mat_data_info <- function(data) {
  arrhytmia_dim <- dim(arrhythmia_data$X)
  print(paste("Rozmiar X: N=", dim(arrhythmia_data$X)[1], ", M=", dim(arrhythmia_data$X)[2], sep=""))
  print(paste("Rozmiar Y:", dim(arrhythmia_data$y)[1]))
}
```

### Wczytywanie danych

Dane wzięty ze strony [Outlier Detection DataSets (ODDS)](http://odds.cs.stonybrook.edu/) oraz [Kaggle](https://www.kaggle.com/)

1. Credit Card Fraud Detection (Kaggle) [link](https://www.kaggle.com/mlg-ulb/creditcardfraud)
2. Arrhythmia dataset (ODDS) [link](http://odds.cs.stonybrook.edu/arrhythmia-dataset/)
3. http (KDDCUP99) dataset (ODDS) [link](http://odds.cs.stonybrook.edu/http-kddcup99-dataset/)
4. [Temporary] kddcup.data_10_percent_corrected - Zbiór danych obejmuje szeroką gamę ???włamań??? symulowanych w wojskowym środowisku sieciowym. [link](http://kdd.ics.uci.edu/databases/kddcup99/kddcup99.html)

#### Wczytywania danych z pliku arrhythmia.mat:

**Opis danych.** Dane składają się z dwóch tabel X i Y:

* X - to wielowymiarowe dane punktowe rozmiaru **N x M**, gdzie N - to liczba punkt, a M - to liczba cech.
* Y - to zbior etykiety o rozmiarze N (liczby punktów), oznaczajczy czy dany punkt jest wartością odstającą (1 = outliers, 0 = inliers) 

```{r}
arrhythmia_data <- load_mat_data("data/arrhythmia.mat")
arrhythmia_data_df <- prepare_mat_data(arrhythmia_data)
print_mat_data_info(arrhythmia_data)
```

#### Wczytywania danych z pliku http.mat:

**Opis danych.** Dane składają się z dwóch tabel X i Y:

* X - to wielowymiarowe dane punktowe rozmiaru **N x M**, gdzie N - to liczba punkt, a M - to liczba cech.
* Y - to zbior etykiety o rozmiarze N (liczby punktów), oznaczajczy czy dany punkt jest wartością odstającą (1 = outliers, 0 = inliers) 

```{r}
# [TODO] problem with open http.mat:
#   Error in readMat5(con, firstFourBytes = firstFourBytes, maxLength = maxLength) : 
#   Reading of MAT v7.3 files is not supported. If possible, save the data in MATLAB using 'save -V6'.

# Uncomment these lines  when the problem is resolved.
# http_data <- load_mat_data("data/http.mat")
# http_data_df <- prepare_mat_data(http_data)
# print_mat_data_info(http_data)
```

#### Wczytywania danych z pliku creditcard.csv:

**Opis danych**:

Zbiór danych zawiera transakcje dokonane kartami kredytowymi we wrześniu 2013 r. przez europejskich posiadaczy kart.
Ten zbiór danych przedstawia transakcje, które miały miejsce w ciągu dwóch dni, w których mamy **492 oszustw** z 284 807 transakcji.

Dane przedstawione za pomocą tabeli o rozmiarze **N x M** gdzie:

* N - ilość transakcyj
* M - liczba cech, których jest 31

Cechy:

1. Ze względu na to, że oryganalnych danych nie można udostępnić, ze względu zabiezpieczęnie danych użytkownika, to mama doczynienia z danymi, które są wynikem redukcji wymiarowości za pomocą PCA (angl. *Principal Component Analysis*).Te cechy w tabele przedstawione jako V1, V2, V3, ... , V28.
2. Time - zawiera liczba sekund która upłynęła między każdą transakcją a pierwszą transakcją w zbiorze danych.
3. Amount - to kwota transakcji.
4. class - przejmuję wartość 1 gdy transakcja jest oszustwej (outliers) i 0 w przeciwnym przypadku.


```{r}
creditcard_data <- load_data("data/creditcard.csv")
head(creditcard_data)
```

### Metryki do sprawdzenia wyników
```{r}
split_data_to_train_and_test <- function(df, persent_split) {
  smp_size <- floor(persent_split * nrow(arrhythmia_data_df))
  ## set the seed to make your partition reproducible
  set.seed(123)
  train_ind <- sample(seq_len(nrow(arrhythmia_data_df)), size = smp_size)
  train <- arrhythmia_data_df[train_ind, ]
  test <- arrhythmia_data_df[-train_ind, ]
  return(list(train=train, test=test))
}
```


### **ETAP 1** Sprawdzenie działania algorytmu na sztucznym zbiorze danych oraz publiczne dostępnych zbiorach



### **ETAP 2** Sprawdzenie wpływu poszczególnych parametrów na jakość uzyskiwanej izolacji wartości odstających



### **ETAP 3** Badanie działania algorytmu z innymi dostępnymi w języku R metodami detekcji wartości odstających, takich jak:

1. K najbliższych sąsiadów (angl.*k-nearest neighbors*)
2. Klasyfikacja jednoklasowa (angl. *One-class SVM*)
3. Lokalny współczynnik wyjątkowości (angl. *Local outlier factor*)
4. Las losowy (angl. *Random Forests*)


K najbliższych sąsiadów

```{r}
run_knn <- function(split_df, k=10) {
  train <- split_df$train
  test <- split_df$test
  train_no_label <- train[,2:ncol(train)]
  test_no_label <- test[,2:ncol(test)]
  train_label <- train[,1]
  
  return(knn(train=train_no_label, test=test_no_label, cl=train_label, k=k))
}

split_train_test_df <- split_data_to_train_and_test(arrhythmia_data_df, 0.8)

pred <- factor(run_knn(split_train_test_df))
expected <-  factor(split_train_test_df$test[,1])
# result
precision <- posPredValue(pred, expected)
recall <- sensitivity(pred, expected)
precision
recall
confusionMatrix(pred, expected)

```

```{r}

```
### **ETAP 4** Ocena działania algorytmu
```{r}

```
